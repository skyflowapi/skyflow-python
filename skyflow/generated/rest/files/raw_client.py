# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.allow_regex import AllowRegex
from ..types.deidentify_file_response import DeidentifyFileResponse
from ..types.deidentify_status_response import DeidentifyStatusResponse
from ..types.entity_types import EntityTypes
from ..types.error_response import ErrorResponse
from ..types.resource_id import ResourceId
from ..types.restrict_regex import RestrictRegex
from ..types.token_type_without_vault import TokenTypeWithoutVault
from ..types.transformations import Transformations
from ..types.uuid_ import Uuid
from ..types.vault_id import VaultId
from .types.deidentify_audio_request_file import DeidentifyAudioRequestFile
from .types.deidentify_audio_request_output_transcription import DeidentifyAudioRequestOutputTranscription
from .types.deidentify_document_request_file import DeidentifyDocumentRequestFile
from .types.deidentify_file_request_file import DeidentifyFileRequestFile
from .types.deidentify_image_request_file import DeidentifyImageRequestFile
from .types.deidentify_image_request_masking_method import DeidentifyImageRequestMaskingMethod
from .types.deidentify_pdf_request_file import DeidentifyPdfRequestFile
from .types.deidentify_presentation_request_file import DeidentifyPresentationRequestFile
from .types.deidentify_spreadsheet_request_file import DeidentifySpreadsheetRequestFile
from .types.deidentify_structured_text_request_file import DeidentifyStructuredTextRequestFile
from .types.deidentify_text_request_file import DeidentifyTextRequestFile

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawFilesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def deidentify_file(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyFileRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a file. This operation includes options applicable to all supported file types.<br/><br/>For more specific options, see the category-specific operations (like <a href='#deidentify_document'>De-identify Document</a>) and the file type-specific opertions (like <a href='#deidentify_pdf'>De-identify PDF</a>).

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyFileRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyFileRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_document(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyDocumentRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a document file. This operation includes options applicable to all supported document file types.<br/><br/>For more specific options, see the file type-specific opertions (like <a href='#deidentify_pdf'>De-identify PDF</a>) where they're available. For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyDocumentRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/document",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyDocumentRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_pdf(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyPdfRequestFile,
        density: typing.Optional[int] = OMIT,
        max_resolution: typing.Optional[int] = OMIT,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a PDF file. This operation includes options specific to PDF files.<br/><br/>For broader file type support, see <a href='#deidentify_document'>De-identify Document</a> and <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyPdfRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        density : typing.Optional[int]
            Pixel density at which to process the PDF file.

        max_resolution : typing.Optional[int]
            Max resolution at which to process the PDF file.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/document/pdf",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyPdfRequestFile, direction="write"
                ),
                "density": density,
                "max_resolution": max_resolution,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_image(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyImageRequestFile,
        output_processed_image: typing.Optional[bool] = OMIT,
        output_ocr_text: typing.Optional[bool] = OMIT,
        masking_method: typing.Optional[DeidentifyImageRequestMaskingMethod] = OMIT,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from an image file. This operation includes options applicable to all supported image file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyImageRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        output_processed_image : typing.Optional[bool]
            If `true`, includes processed image in the output.

        output_ocr_text : typing.Optional[bool]
            If `true`, includes OCR text output in the response.

        masking_method : typing.Optional[DeidentifyImageRequestMaskingMethod]
            Method to mask the entities in the image.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/image",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyImageRequestFile, direction="write"
                ),
                "output_processed_image": output_processed_image,
                "output_ocr_text": output_ocr_text,
                "masking_method": masking_method,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_text(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyTextRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a text file. This operation includes options applicable to all supported image text types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyTextRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/text",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyTextRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_structured_text(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyStructuredTextRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a structured text file. This operation includes options applicable to all supported structured text file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyStructuredTextRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/structured_text",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyStructuredTextRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_spreadsheet(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifySpreadsheetRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a spreadsheet file. This operation includes options applicable to all supported spreadsheet file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifySpreadsheetRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/spreadsheet",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifySpreadsheetRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_presentation(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyPresentationRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a presentation file. This operation includes options applicable to all supported presentation file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyPresentationRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/presentation",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyPresentationRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_audio(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyAudioRequestFile,
        output_processed_audio: typing.Optional[bool] = OMIT,
        output_transcription: typing.Optional[DeidentifyAudioRequestOutputTranscription] = OMIT,
        bleep_gain: typing.Optional[float] = OMIT,
        bleep_frequency: typing.Optional[float] = OMIT,
        bleep_start_padding: typing.Optional[float] = OMIT,
        bleep_stop_padding: typing.Optional[float] = OMIT,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from an audio file. This operation includes options applicable to all supported audio file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyAudioRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        output_processed_audio : typing.Optional[bool]
            If `true`, includes processed audio file in the response.

        output_transcription : typing.Optional[DeidentifyAudioRequestOutputTranscription]
            Type of transcription to output.

        bleep_gain : typing.Optional[float]
            Relative loudness of the bleep in dB. Positive values increase its loudness, and negative values decrease it.

        bleep_frequency : typing.Optional[float]
            The pitch of the bleep sound, in Hz. The higher the number, the higher the pitch.

        bleep_start_padding : typing.Optional[float]
            Padding added to the beginning of a bleep, in seconds.

        bleep_stop_padding : typing.Optional[float]
            Padding added to the end of a bleep, in seconds.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/audio",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyAudioRequestFile, direction="write"
                ),
                "output_processed_audio": output_processed_audio,
                "output_transcription": output_transcription,
                "bleep_gain": bleep_gain,
                "bleep_frequency": bleep_frequency,
                "bleep_start_padding": bleep_start_padding,
                "bleep_stop_padding": bleep_stop_padding,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_run(
        self, run_id: Uuid, *, vault_id: ResourceId, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeidentifyStatusResponse]:
        """
        Returns the status of the detect run.

        Parameters
        ----------
        run_id : Uuid
            ID of the detect run.

        vault_id : ResourceId
            ID of the vault.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyStatusResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/detect/runs/{jsonable_encoder(run_id)}",
            method="GET",
            params={
                "vault_id": vault_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyStatusResponse,
                    parse_obj_as(
                        type_=DeidentifyStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawFilesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def deidentify_file(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyFileRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a file. This operation includes options applicable to all supported file types.<br/><br/>For more specific options, see the category-specific operations (like <a href='#deidentify_document'>De-identify Document</a>) and the file type-specific opertions (like <a href='#deidentify_pdf'>De-identify PDF</a>).

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyFileRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyFileRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_document(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyDocumentRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a document file. This operation includes options applicable to all supported document file types.<br/><br/>For more specific options, see the file type-specific opertions (like <a href='#deidentify_pdf'>De-identify PDF</a>) where they're available. For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyDocumentRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/document",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyDocumentRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_pdf(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyPdfRequestFile,
        density: typing.Optional[int] = OMIT,
        max_resolution: typing.Optional[int] = OMIT,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a PDF file. This operation includes options specific to PDF files.<br/><br/>For broader file type support, see <a href='#deidentify_document'>De-identify Document</a> and <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyPdfRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        density : typing.Optional[int]
            Pixel density at which to process the PDF file.

        max_resolution : typing.Optional[int]
            Max resolution at which to process the PDF file.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/document/pdf",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyPdfRequestFile, direction="write"
                ),
                "density": density,
                "max_resolution": max_resolution,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_image(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyImageRequestFile,
        output_processed_image: typing.Optional[bool] = OMIT,
        output_ocr_text: typing.Optional[bool] = OMIT,
        masking_method: typing.Optional[DeidentifyImageRequestMaskingMethod] = OMIT,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from an image file. This operation includes options applicable to all supported image file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyImageRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        output_processed_image : typing.Optional[bool]
            If `true`, includes processed image in the output.

        output_ocr_text : typing.Optional[bool]
            If `true`, includes OCR text output in the response.

        masking_method : typing.Optional[DeidentifyImageRequestMaskingMethod]
            Method to mask the entities in the image.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/image",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyImageRequestFile, direction="write"
                ),
                "output_processed_image": output_processed_image,
                "output_ocr_text": output_ocr_text,
                "masking_method": masking_method,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_text(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyTextRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a text file. This operation includes options applicable to all supported image text types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyTextRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/text",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyTextRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_structured_text(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyStructuredTextRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a structured text file. This operation includes options applicable to all supported structured text file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyStructuredTextRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/structured_text",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyStructuredTextRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_spreadsheet(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifySpreadsheetRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a spreadsheet file. This operation includes options applicable to all supported spreadsheet file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifySpreadsheetRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/spreadsheet",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifySpreadsheetRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_presentation(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyPresentationRequestFile,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a presentation file. This operation includes options applicable to all supported presentation file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyPresentationRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/presentation",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyPresentationRequestFile, direction="write"
                ),
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_audio(
        self,
        *,
        vault_id: VaultId,
        file: DeidentifyAudioRequestFile,
        output_processed_audio: typing.Optional[bool] = OMIT,
        output_transcription: typing.Optional[DeidentifyAudioRequestOutputTranscription] = OMIT,
        bleep_gain: typing.Optional[float] = OMIT,
        bleep_frequency: typing.Optional[float] = OMIT,
        bleep_start_padding: typing.Optional[float] = OMIT,
        bleep_stop_padding: typing.Optional[float] = OMIT,
        entity_types: typing.Optional[EntityTypes] = OMIT,
        token_type: typing.Optional[TokenTypeWithoutVault] = OMIT,
        allow_regex: typing.Optional[AllowRegex] = OMIT,
        restrict_regex: typing.Optional[RestrictRegex] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from an audio file. This operation includes options applicable to all supported audio file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        vault_id : VaultId

        file : DeidentifyAudioRequestFile
            File to de-identify. Files are specified as Base64-encoded data.

        output_processed_audio : typing.Optional[bool]
            If `true`, includes processed audio file in the response.

        output_transcription : typing.Optional[DeidentifyAudioRequestOutputTranscription]
            Type of transcription to output.

        bleep_gain : typing.Optional[float]
            Relative loudness of the bleep in dB. Positive values increase its loudness, and negative values decrease it.

        bleep_frequency : typing.Optional[float]
            The pitch of the bleep sound, in Hz. The higher the number, the higher the pitch.

        bleep_start_padding : typing.Optional[float]
            Padding added to the beginning of a bleep, in seconds.

        bleep_stop_padding : typing.Optional[float]
            Padding added to the end of a bleep, in seconds.

        entity_types : typing.Optional[EntityTypes]

        token_type : typing.Optional[TokenTypeWithoutVault]

        allow_regex : typing.Optional[AllowRegex]

        restrict_regex : typing.Optional[RestrictRegex]

        transformations : typing.Optional[Transformations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/audio",
            method="POST",
            json={
                "vault_id": vault_id,
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=DeidentifyAudioRequestFile, direction="write"
                ),
                "output_processed_audio": output_processed_audio,
                "output_transcription": output_transcription,
                "bleep_gain": bleep_gain,
                "bleep_frequency": bleep_frequency,
                "bleep_start_padding": bleep_start_padding,
                "bleep_stop_padding": bleep_stop_padding,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeWithoutVault, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_run(
        self, run_id: Uuid, *, vault_id: ResourceId, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeidentifyStatusResponse]:
        """
        Returns the status of the detect run.

        Parameters
        ----------
        run_id : Uuid
            ID of the detect run.

        vault_id : ResourceId
            ID of the vault.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyStatusResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/detect/runs/{jsonable_encoder(run_id)}",
            method="GET",
            params={
                "vault_id": vault_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyStatusResponse,
                    parse_obj_as(
                        type_=DeidentifyStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
