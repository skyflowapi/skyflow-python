# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.internal_server_error import InternalServerError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.deidentify_file_response import DeidentifyFileResponse
from ..types.detect_runs_response import DetectRunsResponse
from ..types.error_response import ErrorResponse
from ..types.file_data import FileData
from ..types.file_data_deidentify_audio import FileDataDeidentifyAudio
from ..types.file_data_deidentify_document import FileDataDeidentifyDocument
from ..types.file_data_deidentify_image import FileDataDeidentifyImage
from ..types.file_data_deidentify_pdf import FileDataDeidentifyPdf
from ..types.file_data_deidentify_presentation import FileDataDeidentifyPresentation
from ..types.file_data_deidentify_spreadsheet import FileDataDeidentifySpreadsheet
from ..types.file_data_deidentify_structured_text import FileDataDeidentifyStructuredText
from ..types.file_data_deidentify_text import FileDataDeidentifyText
from ..types.file_data_reidentify_file import FileDataReidentifyFile
from ..types.format import Format
from ..types.reidentify_file_response import ReidentifyFileResponse
from ..types.token_type_mapping import TokenTypeMapping
from ..types.transformations import Transformations
from .types.deidentify_file_audio_request_deidentify_audio_entity_types_item import (
    DeidentifyFileAudioRequestDeidentifyAudioEntityTypesItem,
)
from .types.deidentify_file_audio_request_deidentify_audio_output_transcription import (
    DeidentifyFileAudioRequestDeidentifyAudioOutputTranscription,
)
from .types.deidentify_file_document_pdf_request_deidentify_pdf_entity_types_item import (
    DeidentifyFileDocumentPdfRequestDeidentifyPdfEntityTypesItem,
)
from .types.deidentify_file_image_request_deidentify_image_entity_types_item import (
    DeidentifyFileImageRequestDeidentifyImageEntityTypesItem,
)
from .types.deidentify_file_image_request_deidentify_image_masking_method import (
    DeidentifyFileImageRequestDeidentifyImageMaskingMethod,
)
from .types.deidentify_file_request_deidentify_document_entity_types_item import (
    DeidentifyFileRequestDeidentifyDocumentEntityTypesItem,
)
from .types.deidentify_file_request_deidentify_presentation_entity_types_item import (
    DeidentifyFileRequestDeidentifyPresentationEntityTypesItem,
)
from .types.deidentify_file_request_deidentify_spreadsheet_entity_types_item import (
    DeidentifyFileRequestDeidentifySpreadsheetEntityTypesItem,
)
from .types.deidentify_file_request_deidentify_structured_text_entity_types_item import (
    DeidentifyFileRequestDeidentifyStructuredTextEntityTypesItem,
)
from .types.deidentify_file_request_deidentify_text_entity_types_item import (
    DeidentifyFileRequestDeidentifyTextEntityTypesItem,
)
from .types.deidentify_file_request_entity_types_item import DeidentifyFileRequestEntityTypesItem

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawFilesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def deidentify_file(
        self,
        *,
        file: FileData,
        vault_id: str,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileRequestEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a file. This operation includes options applicable to all supported file types.<br/><br/>For more specific options, see the category-specific operations (like <a href='#deidentify_document'>De-identify Document</a>) and the file type-specific opertions (like <a href='#deidentify_pdf'>De-identify PDF</a>).

        Parameters
        ----------
        file : FileData

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(object_=file, annotation=FileData, direction="write"),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_audio(
        self,
        *,
        file: FileDataDeidentifyAudio,
        vault_id: str,
        output_transcription: typing.Optional[DeidentifyFileAudioRequestDeidentifyAudioOutputTranscription] = OMIT,
        output_processed_audio: typing.Optional[bool] = OMIT,
        bleep_start_padding: typing.Optional[float] = OMIT,
        bleep_stop_padding: typing.Optional[float] = OMIT,
        bleep_frequency: typing.Optional[int] = OMIT,
        bleep_gain: typing.Optional[int] = OMIT,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileAudioRequestDeidentifyAudioEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from an audio file. This operation includes options applicable to all supported audio file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyAudio

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        output_transcription : typing.Optional[DeidentifyFileAudioRequestDeidentifyAudioOutputTranscription]
            Type of transcription to output.

        output_processed_audio : typing.Optional[bool]
            Whether to include the processed audio file in the response.

        bleep_start_padding : typing.Optional[float]
            Padding added to the beginning of a bleep, in seconds.

        bleep_stop_padding : typing.Optional[float]
            Padding added to the end of a bleep, in seconds.

        bleep_frequency : typing.Optional[int]
            The pitch of the bleep sound, in Hz. The higher the number, the higher the pitch.

        bleep_gain : typing.Optional[int]
            Relative loudness of the bleep in dB. Positive values increase its loudness, and negative values decrease it.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileAudioRequestDeidentifyAudioEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/audio",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyAudio, direction="write"
                ),
                "vault_id": vault_id,
                "output_transcription": output_transcription,
                "output_processed_audio": output_processed_audio,
                "bleep_start_padding": bleep_start_padding,
                "bleep_stop_padding": bleep_stop_padding,
                "bleep_frequency": bleep_frequency,
                "bleep_gain": bleep_gain,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_document(
        self,
        *,
        file: FileDataDeidentifyDocument,
        vault_id: str,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyDocumentEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a document file. This operation includes options applicable to all supported document file types.<br/><br/>For more specific options, see the file type-specific opertions (like <a href='#deidentify_pdf'>De-identify PDF</a>) where they're available. For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyDocument

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyDocumentEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/document",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyDocument, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_pdf(
        self,
        *,
        file: FileDataDeidentifyPdf,
        vault_id: str,
        density: typing.Optional[int] = OMIT,
        max_resolution: typing.Optional[int] = OMIT,
        entity_types: typing.Optional[
            typing.Sequence[DeidentifyFileDocumentPdfRequestDeidentifyPdfEntityTypesItem]
        ] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a PDF file. This operation includes options specific to PDF files.<br/><br/>For broader file type support, see <a href='#deidentify_document'>De-identify Document</a> and <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyPdf

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        density : typing.Optional[int]
            Pixel density at which to process the PDF file.

        max_resolution : typing.Optional[int]
            Max resolution at which to process the PDF file.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileDocumentPdfRequestDeidentifyPdfEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/document/pdf",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyPdf, direction="write"
                ),
                "vault_id": vault_id,
                "density": density,
                "max_resolution": max_resolution,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_image(
        self,
        *,
        file: FileDataDeidentifyImage,
        vault_id: str,
        output_processed_image: typing.Optional[bool] = OMIT,
        output_ocr_text: typing.Optional[bool] = OMIT,
        masking_method: typing.Optional[DeidentifyFileImageRequestDeidentifyImageMaskingMethod] = OMIT,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileImageRequestDeidentifyImageEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from an image file. This operation includes options applicable to all supported image file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyImage

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        output_processed_image : typing.Optional[bool]
            If `true`, includes processed image in the output.

        output_ocr_text : typing.Optional[bool]
            If `true`, includes text detected by OCR in the response.

        masking_method : typing.Optional[DeidentifyFileImageRequestDeidentifyImageMaskingMethod]
            Method to mask the entities in the image.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileImageRequestDeidentifyImageEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/image",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyImage, direction="write"
                ),
                "vault_id": vault_id,
                "output_processed_image": output_processed_image,
                "output_ocr_text": output_ocr_text,
                "masking_method": masking_method,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_presentation(
        self,
        *,
        file: FileDataDeidentifyPresentation,
        vault_id: str,
        entity_types: typing.Optional[
            typing.Sequence[DeidentifyFileRequestDeidentifyPresentationEntityTypesItem]
        ] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a presentation file. This operation includes options applicable to all supported presentation file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyPresentation

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyPresentationEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/presentation",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyPresentation, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_spreadsheet(
        self,
        *,
        file: FileDataDeidentifySpreadsheet,
        vault_id: str,
        entity_types: typing.Optional[
            typing.Sequence[DeidentifyFileRequestDeidentifySpreadsheetEntityTypesItem]
        ] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a spreadsheet file. This operation includes options applicable to all supported spreadsheet file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifySpreadsheet

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifySpreadsheetEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/spreadsheet",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifySpreadsheet, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_structured_text(
        self,
        *,
        file: FileDataDeidentifyStructuredText,
        vault_id: str,
        entity_types: typing.Optional[
            typing.Sequence[DeidentifyFileRequestDeidentifyStructuredTextEntityTypesItem]
        ] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a structured text file. This operation includes options applicable to all supported structured text file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyStructuredText

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyStructuredTextEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/structured_text",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyStructuredText, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def deidentify_text(
        self,
        *,
        file: FileDataDeidentifyText,
        vault_id: str,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyTextEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a text file. This operation includes options applicable to all supported image text types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyText

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyTextEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/text",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyText, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def reidentify_file(
        self,
        *,
        file: FileDataReidentifyFile,
        vault_id: str,
        format: typing.Optional[Format] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ReidentifyFileResponse]:
        """
        Re-identifies tokens in a file.

        Parameters
        ----------
        file : FileDataReidentifyFile

        vault_id : str
            ID of the vault where the entities are stored.

        format : typing.Optional[Format]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReidentifyFileResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/reidentify/file",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataReidentifyFile, direction="write"
                ),
                "vault_id": vault_id,
                "format": convert_and_respect_annotation_metadata(object_=format, annotation=Format, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReidentifyFileResponse,
                    parse_obj_as(
                        type_=ReidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_run(
        self,
        run_id: str,
        *,
        vault_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DetectRunsResponse]:
        """
        Returns the status of a detect run.

        Parameters
        ----------
        run_id : str

        vault_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DetectRunsResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/detect/runs/{jsonable_encoder(run_id)}",
            method="GET",
            params={
                "vault_id": vault_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DetectRunsResponse,
                    parse_obj_as(
                        type_=DetectRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawFilesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def deidentify_file(
        self,
        *,
        file: FileData,
        vault_id: str,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileRequestEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a file. This operation includes options applicable to all supported file types.<br/><br/>For more specific options, see the category-specific operations (like <a href='#deidentify_document'>De-identify Document</a>) and the file type-specific opertions (like <a href='#deidentify_pdf'>De-identify PDF</a>).

        Parameters
        ----------
        file : FileData

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(object_=file, annotation=FileData, direction="write"),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_audio(
        self,
        *,
        file: FileDataDeidentifyAudio,
        vault_id: str,
        output_transcription: typing.Optional[DeidentifyFileAudioRequestDeidentifyAudioOutputTranscription] = OMIT,
        output_processed_audio: typing.Optional[bool] = OMIT,
        bleep_start_padding: typing.Optional[float] = OMIT,
        bleep_stop_padding: typing.Optional[float] = OMIT,
        bleep_frequency: typing.Optional[int] = OMIT,
        bleep_gain: typing.Optional[int] = OMIT,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileAudioRequestDeidentifyAudioEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from an audio file. This operation includes options applicable to all supported audio file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyAudio

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        output_transcription : typing.Optional[DeidentifyFileAudioRequestDeidentifyAudioOutputTranscription]
            Type of transcription to output.

        output_processed_audio : typing.Optional[bool]
            Whether to include the processed audio file in the response.

        bleep_start_padding : typing.Optional[float]
            Padding added to the beginning of a bleep, in seconds.

        bleep_stop_padding : typing.Optional[float]
            Padding added to the end of a bleep, in seconds.

        bleep_frequency : typing.Optional[int]
            The pitch of the bleep sound, in Hz. The higher the number, the higher the pitch.

        bleep_gain : typing.Optional[int]
            Relative loudness of the bleep in dB. Positive values increase its loudness, and negative values decrease it.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileAudioRequestDeidentifyAudioEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/audio",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyAudio, direction="write"
                ),
                "vault_id": vault_id,
                "output_transcription": output_transcription,
                "output_processed_audio": output_processed_audio,
                "bleep_start_padding": bleep_start_padding,
                "bleep_stop_padding": bleep_stop_padding,
                "bleep_frequency": bleep_frequency,
                "bleep_gain": bleep_gain,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_document(
        self,
        *,
        file: FileDataDeidentifyDocument,
        vault_id: str,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyDocumentEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a document file. This operation includes options applicable to all supported document file types.<br/><br/>For more specific options, see the file type-specific opertions (like <a href='#deidentify_pdf'>De-identify PDF</a>) where they're available. For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyDocument

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyDocumentEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/document",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyDocument, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_pdf(
        self,
        *,
        file: FileDataDeidentifyPdf,
        vault_id: str,
        density: typing.Optional[int] = OMIT,
        max_resolution: typing.Optional[int] = OMIT,
        entity_types: typing.Optional[
            typing.Sequence[DeidentifyFileDocumentPdfRequestDeidentifyPdfEntityTypesItem]
        ] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a PDF file. This operation includes options specific to PDF files.<br/><br/>For broader file type support, see <a href='#deidentify_document'>De-identify Document</a> and <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyPdf

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        density : typing.Optional[int]
            Pixel density at which to process the PDF file.

        max_resolution : typing.Optional[int]
            Max resolution at which to process the PDF file.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileDocumentPdfRequestDeidentifyPdfEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/document/pdf",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyPdf, direction="write"
                ),
                "vault_id": vault_id,
                "density": density,
                "max_resolution": max_resolution,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_image(
        self,
        *,
        file: FileDataDeidentifyImage,
        vault_id: str,
        output_processed_image: typing.Optional[bool] = OMIT,
        output_ocr_text: typing.Optional[bool] = OMIT,
        masking_method: typing.Optional[DeidentifyFileImageRequestDeidentifyImageMaskingMethod] = OMIT,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileImageRequestDeidentifyImageEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from an image file. This operation includes options applicable to all supported image file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyImage

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        output_processed_image : typing.Optional[bool]
            If `true`, includes processed image in the output.

        output_ocr_text : typing.Optional[bool]
            If `true`, includes text detected by OCR in the response.

        masking_method : typing.Optional[DeidentifyFileImageRequestDeidentifyImageMaskingMethod]
            Method to mask the entities in the image.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileImageRequestDeidentifyImageEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/image",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyImage, direction="write"
                ),
                "vault_id": vault_id,
                "output_processed_image": output_processed_image,
                "output_ocr_text": output_ocr_text,
                "masking_method": masking_method,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_presentation(
        self,
        *,
        file: FileDataDeidentifyPresentation,
        vault_id: str,
        entity_types: typing.Optional[
            typing.Sequence[DeidentifyFileRequestDeidentifyPresentationEntityTypesItem]
        ] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a presentation file. This operation includes options applicable to all supported presentation file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyPresentation

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyPresentationEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/presentation",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyPresentation, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_spreadsheet(
        self,
        *,
        file: FileDataDeidentifySpreadsheet,
        vault_id: str,
        entity_types: typing.Optional[
            typing.Sequence[DeidentifyFileRequestDeidentifySpreadsheetEntityTypesItem]
        ] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a spreadsheet file. This operation includes options applicable to all supported spreadsheet file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifySpreadsheet

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifySpreadsheetEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/spreadsheet",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifySpreadsheet, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_structured_text(
        self,
        *,
        file: FileDataDeidentifyStructuredText,
        vault_id: str,
        entity_types: typing.Optional[
            typing.Sequence[DeidentifyFileRequestDeidentifyStructuredTextEntityTypesItem]
        ] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a structured text file. This operation includes options applicable to all supported structured text file types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyStructuredText

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyStructuredTextEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/structured_text",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyStructuredText, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def deidentify_text(
        self,
        *,
        file: FileDataDeidentifyText,
        vault_id: str,
        entity_types: typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyTextEntityTypesItem]] = OMIT,
        token_type: typing.Optional[TokenTypeMapping] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        transformations: typing.Optional[Transformations] = OMIT,
        configuration_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeidentifyFileResponse]:
        """
        De-identifies sensitive data from a text file. This operation includes options applicable to all supported image text types.<br/><br/>For broader file type support, see <a href='#deidentify_file'>De-identify File</a>.

        Parameters
        ----------
        file : FileDataDeidentifyText

        vault_id : str
            ID of a vault that you have Detect Invoker or Vault Owner permissions for.

        entity_types : typing.Optional[typing.Sequence[DeidentifyFileRequestDeidentifyTextEntityTypesItem]]
            Entities to detect and de-identify.

        token_type : typing.Optional[TokenTypeMapping]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to display in plaintext. Entities appear in plaintext if an expression matches either the entirety of a detected entity or a substring of it. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to replace with '[RESTRICTED]'. Expressions must match the entirety of a detected entity, not just a substring, for the entity to be restricted. Expressions don't match across entity boundaries. If a string or entity matches both `allow_regex` and `restrict_regex`, the entity is displayed in plaintext. If a string is detected as an entity and a `restrict_regex` pattern matches the entire detected entity, the entity is replaced with '[RESTRICTED]'. If a string is detected as an entity but a `restrict_regex` pattern only matches a substring of it, the `restrict_regex` pattern is ignored, and the entity is processed according to the specified tokenization and transformation settings.

        transformations : typing.Optional[Transformations]

        configuration_id : typing.Optional[str]
            ID of the Detect configuration to use for de-identification. Can't be specified with fields other than `vault_id`, `text`, and `file`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/deidentify/file/text",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataDeidentifyText, direction="write"
                ),
                "vault_id": vault_id,
                "entity_types": entity_types,
                "token_type": convert_and_respect_annotation_metadata(
                    object_=token_type, annotation=TokenTypeMapping, direction="write"
                ),
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "transformations": convert_and_respect_annotation_metadata(
                    object_=transformations, annotation=Transformations, direction="write"
                ),
                "configuration_id": configuration_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeidentifyFileResponse,
                    parse_obj_as(
                        type_=DeidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def reidentify_file(
        self,
        *,
        file: FileDataReidentifyFile,
        vault_id: str,
        format: typing.Optional[Format] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ReidentifyFileResponse]:
        """
        Re-identifies tokens in a file.

        Parameters
        ----------
        file : FileDataReidentifyFile

        vault_id : str
            ID of the vault where the entities are stored.

        format : typing.Optional[Format]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReidentifyFileResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/reidentify/file",
            method="POST",
            json={
                "file": convert_and_respect_annotation_metadata(
                    object_=file, annotation=FileDataReidentifyFile, direction="write"
                ),
                "vault_id": vault_id,
                "format": convert_and_respect_annotation_metadata(object_=format, annotation=Format, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReidentifyFileResponse,
                    parse_obj_as(
                        type_=ReidentifyFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_run(
        self,
        run_id: str,
        *,
        vault_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DetectRunsResponse]:
        """
        Returns the status of a detect run.

        Parameters
        ----------
        run_id : str

        vault_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DetectRunsResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/detect/runs/{jsonable_encoder(run_id)}",
            method="GET",
            params={
                "vault_id": vault_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DetectRunsResponse,
                    parse_obj_as(
                        type_=DetectRunsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
