# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.not_found_error import NotFoundError
from ..types.detect_data_accuracy import DetectDataAccuracy
from ..types.detect_data_entities import DetectDataEntities
from ..types.detect_file_request_data_type import DetectFileRequestDataType
from ..types.detect_request_deidentify_option import DetectRequestDeidentifyOption
from ..types.v_1_advanced_options import V1AdvancedOptions
from ..types.v_1_audio_config import V1AudioConfig
from ..types.v_1_detect_file_response import V1DetectFileResponse
from ..types.v_1_detect_status_response import V1DetectStatusResponse
from ..types.v_1_detect_text_response import V1DetectTextResponse
from ..types.v_1_file_data_format import V1FileDataFormat
from ..types.v_1_image_options import V1ImageOptions
from ..types.v_1_pdf_config import V1PdfConfig

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawDeprecatedClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def detect_service_detect_file_input(
        self,
        *,
        file: str,
        data_format: V1FileDataFormat,
        input_type: DetectFileRequestDataType,
        vault_id: str,
        session_id: typing.Optional[str] = OMIT,
        restrict_entity_types: typing.Optional[typing.Sequence[DetectDataEntities]] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        return_entities: typing.Optional[bool] = OMIT,
        accuracy: typing.Optional[DetectDataAccuracy] = OMIT,
        audio: typing.Optional[V1AudioConfig] = OMIT,
        image: typing.Optional[V1ImageOptions] = OMIT,
        pdf: typing.Optional[V1PdfConfig] = OMIT,
        advanced_options: typing.Optional[V1AdvancedOptions] = OMIT,
        deidentify_token_format: typing.Optional[DetectRequestDeidentifyOption] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1DetectFileResponse]:
        """
        <b>Note</b>: This operation is deprecated. Use one of the <a href=#De-identify%20File>De-identify File</a> operations.<br/><br/>Detects and deidentifies sensitive data from image, audio, and video files.

        Parameters
        ----------
        file : str
            Path of the file or base64-encoded data that has to be processed.

        data_format : V1FileDataFormat

        input_type : DetectFileRequestDataType

        vault_id : str
            ID of the vault.

        session_id : typing.Optional[str]
            Will give a handle to delete the tokens generated during a specific interaction.

        restrict_entity_types : typing.Optional[typing.Sequence[DetectDataEntities]]
            Entities to detect and deidentify.

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to ignore when detecting entities.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to always restrict. Strings matching these regular expressions are replaced with 'RESTRICTED'.

        return_entities : typing.Optional[bool]
            If `true`, returns the details for the detected entities.

        accuracy : typing.Optional[DetectDataAccuracy]

        audio : typing.Optional[V1AudioConfig]

        image : typing.Optional[V1ImageOptions]

        pdf : typing.Optional[V1PdfConfig]

        advanced_options : typing.Optional[V1AdvancedOptions]

        deidentify_token_format : typing.Optional[DetectRequestDeidentifyOption]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1DetectFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/file",
            method="POST",
            json={
                "file": file,
                "data_format": data_format,
                "input_type": input_type,
                "vault_id": vault_id,
                "session_id": session_id,
                "restrict_entity_types": restrict_entity_types,
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "return_entities": return_entities,
                "accuracy": accuracy,
                "audio": convert_and_respect_annotation_metadata(
                    object_=audio, annotation=V1AudioConfig, direction="write"
                ),
                "image": convert_and_respect_annotation_metadata(
                    object_=image, annotation=V1ImageOptions, direction="write"
                ),
                "pdf": convert_and_respect_annotation_metadata(object_=pdf, annotation=V1PdfConfig, direction="write"),
                "advanced_options": convert_and_respect_annotation_metadata(
                    object_=advanced_options, annotation=V1AdvancedOptions, direction="write"
                ),
                "deidentify_token_format": deidentify_token_format,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DetectFileResponse,
                    parse_obj_as(
                        type_=V1DetectFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def detect_service_detect_status(
        self, id: str, *, vault_id: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[V1DetectStatusResponse]:
        """
        <b>Note</b>: This operation is deprecated. Use <a href=#get_detect_run>Get Detect Run</a>.<br/><br/>Returns the status of a file deidentification request.

        Parameters
        ----------
        id : str
            ID of the deidentification request.

        vault_id : typing.Optional[str]
            ID of the vault.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1DetectStatusResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/detect/status/{jsonable_encoder(id)}",
            method="GET",
            params={
                "vault_id": vault_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DetectStatusResponse,
                    parse_obj_as(
                        type_=V1DetectStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def detect_service_detect_text(
        self,
        *,
        text: str,
        vault_id: str,
        session_id: typing.Optional[str] = OMIT,
        restrict_entity_types: typing.Optional[typing.Sequence[DetectDataEntities]] = OMIT,
        deidentify_token_format: typing.Optional[DetectRequestDeidentifyOption] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        return_entities: typing.Optional[bool] = OMIT,
        accuracy: typing.Optional[DetectDataAccuracy] = OMIT,
        advanced_options: typing.Optional[V1AdvancedOptions] = OMIT,
        store_entities: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1DetectTextResponse]:
        """
        <b>Note</b>: This operation is deprecated. Use <a href=#deidentify_string>De-identify String</a>.<br/><br/>Detects and deidentifies sensitive data from text.

        Parameters
        ----------
        text : str
            Data to deidentify.

        vault_id : str
            ID of the vault.

        session_id : typing.Optional[str]
            Will give a handle to delete the tokens generated during a specific interaction.

        restrict_entity_types : typing.Optional[typing.Sequence[DetectDataEntities]]
            Entities to detect and deidentify.

        deidentify_token_format : typing.Optional[DetectRequestDeidentifyOption]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to ignore when detecting entities.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to always restrict. Strings matching these regular expressions are replaced with 'RESTRICTED'.

        return_entities : typing.Optional[bool]
            If `true`, returns the details for the detected entities.

        accuracy : typing.Optional[DetectDataAccuracy]

        advanced_options : typing.Optional[V1AdvancedOptions]

        store_entities : typing.Optional[bool]
            Indicates whether entities should be stored in the vault.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1DetectTextResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/detect/text",
            method="POST",
            json={
                "text": text,
                "vault_id": vault_id,
                "session_id": session_id,
                "restrict_entity_types": restrict_entity_types,
                "deidentify_token_format": deidentify_token_format,
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "return_entities": return_entities,
                "accuracy": accuracy,
                "advanced_options": convert_and_respect_annotation_metadata(
                    object_=advanced_options, annotation=V1AdvancedOptions, direction="write"
                ),
                "store_entities": store_entities,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DetectTextResponse,
                    parse_obj_as(
                        type_=V1DetectTextResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawDeprecatedClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def detect_service_detect_file_input(
        self,
        *,
        file: str,
        data_format: V1FileDataFormat,
        input_type: DetectFileRequestDataType,
        vault_id: str,
        session_id: typing.Optional[str] = OMIT,
        restrict_entity_types: typing.Optional[typing.Sequence[DetectDataEntities]] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        return_entities: typing.Optional[bool] = OMIT,
        accuracy: typing.Optional[DetectDataAccuracy] = OMIT,
        audio: typing.Optional[V1AudioConfig] = OMIT,
        image: typing.Optional[V1ImageOptions] = OMIT,
        pdf: typing.Optional[V1PdfConfig] = OMIT,
        advanced_options: typing.Optional[V1AdvancedOptions] = OMIT,
        deidentify_token_format: typing.Optional[DetectRequestDeidentifyOption] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1DetectFileResponse]:
        """
        <b>Note</b>: This operation is deprecated. Use one of the <a href=#De-identify%20File>De-identify File</a> operations.<br/><br/>Detects and deidentifies sensitive data from image, audio, and video files.

        Parameters
        ----------
        file : str
            Path of the file or base64-encoded data that has to be processed.

        data_format : V1FileDataFormat

        input_type : DetectFileRequestDataType

        vault_id : str
            ID of the vault.

        session_id : typing.Optional[str]
            Will give a handle to delete the tokens generated during a specific interaction.

        restrict_entity_types : typing.Optional[typing.Sequence[DetectDataEntities]]
            Entities to detect and deidentify.

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to ignore when detecting entities.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to always restrict. Strings matching these regular expressions are replaced with 'RESTRICTED'.

        return_entities : typing.Optional[bool]
            If `true`, returns the details for the detected entities.

        accuracy : typing.Optional[DetectDataAccuracy]

        audio : typing.Optional[V1AudioConfig]

        image : typing.Optional[V1ImageOptions]

        pdf : typing.Optional[V1PdfConfig]

        advanced_options : typing.Optional[V1AdvancedOptions]

        deidentify_token_format : typing.Optional[DetectRequestDeidentifyOption]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1DetectFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/file",
            method="POST",
            json={
                "file": file,
                "data_format": data_format,
                "input_type": input_type,
                "vault_id": vault_id,
                "session_id": session_id,
                "restrict_entity_types": restrict_entity_types,
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "return_entities": return_entities,
                "accuracy": accuracy,
                "audio": convert_and_respect_annotation_metadata(
                    object_=audio, annotation=V1AudioConfig, direction="write"
                ),
                "image": convert_and_respect_annotation_metadata(
                    object_=image, annotation=V1ImageOptions, direction="write"
                ),
                "pdf": convert_and_respect_annotation_metadata(object_=pdf, annotation=V1PdfConfig, direction="write"),
                "advanced_options": convert_and_respect_annotation_metadata(
                    object_=advanced_options, annotation=V1AdvancedOptions, direction="write"
                ),
                "deidentify_token_format": deidentify_token_format,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DetectFileResponse,
                    parse_obj_as(
                        type_=V1DetectFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def detect_service_detect_status(
        self, id: str, *, vault_id: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[V1DetectStatusResponse]:
        """
        <b>Note</b>: This operation is deprecated. Use <a href=#get_detect_run>Get Detect Run</a>.<br/><br/>Returns the status of a file deidentification request.

        Parameters
        ----------
        id : str
            ID of the deidentification request.

        vault_id : typing.Optional[str]
            ID of the vault.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1DetectStatusResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/detect/status/{jsonable_encoder(id)}",
            method="GET",
            params={
                "vault_id": vault_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DetectStatusResponse,
                    parse_obj_as(
                        type_=V1DetectStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def detect_service_detect_text(
        self,
        *,
        text: str,
        vault_id: str,
        session_id: typing.Optional[str] = OMIT,
        restrict_entity_types: typing.Optional[typing.Sequence[DetectDataEntities]] = OMIT,
        deidentify_token_format: typing.Optional[DetectRequestDeidentifyOption] = OMIT,
        allow_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        restrict_regex: typing.Optional[typing.Sequence[str]] = OMIT,
        return_entities: typing.Optional[bool] = OMIT,
        accuracy: typing.Optional[DetectDataAccuracy] = OMIT,
        advanced_options: typing.Optional[V1AdvancedOptions] = OMIT,
        store_entities: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1DetectTextResponse]:
        """
        <b>Note</b>: This operation is deprecated. Use <a href=#deidentify_string>De-identify String</a>.<br/><br/>Detects and deidentifies sensitive data from text.

        Parameters
        ----------
        text : str
            Data to deidentify.

        vault_id : str
            ID of the vault.

        session_id : typing.Optional[str]
            Will give a handle to delete the tokens generated during a specific interaction.

        restrict_entity_types : typing.Optional[typing.Sequence[DetectDataEntities]]
            Entities to detect and deidentify.

        deidentify_token_format : typing.Optional[DetectRequestDeidentifyOption]

        allow_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to ignore when detecting entities.

        restrict_regex : typing.Optional[typing.Sequence[str]]
            Regular expressions to always restrict. Strings matching these regular expressions are replaced with 'RESTRICTED'.

        return_entities : typing.Optional[bool]
            If `true`, returns the details for the detected entities.

        accuracy : typing.Optional[DetectDataAccuracy]

        advanced_options : typing.Optional[V1AdvancedOptions]

        store_entities : typing.Optional[bool]
            Indicates whether entities should be stored in the vault.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1DetectTextResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/detect/text",
            method="POST",
            json={
                "text": text,
                "vault_id": vault_id,
                "session_id": session_id,
                "restrict_entity_types": restrict_entity_types,
                "deidentify_token_format": deidentify_token_format,
                "allow_regex": allow_regex,
                "restrict_regex": restrict_regex,
                "return_entities": return_entities,
                "accuracy": accuracy,
                "advanced_options": convert_and_respect_annotation_metadata(
                    object_=advanced_options, annotation=V1AdvancedOptions, direction="write"
                ),
                "store_entities": store_entities,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DetectTextResponse,
                    parse_obj_as(
                        type_=V1DetectTextResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
