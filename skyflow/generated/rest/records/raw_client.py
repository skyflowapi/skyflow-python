# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from .. import core
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.error_response import ErrorResponse
from ..types.upload_file_v_2_response import UploadFileV2Response
from ..types.v_1_batch_operation_response import V1BatchOperationResponse
from ..types.v_1_batch_record import V1BatchRecord
from ..types.v_1_bulk_delete_record_response import V1BulkDeleteRecordResponse
from ..types.v_1_bulk_get_record_response import V1BulkGetRecordResponse
from ..types.v_1_byot import V1Byot
from ..types.v_1_delete_file_response import V1DeleteFileResponse
from ..types.v_1_delete_record_response import V1DeleteRecordResponse
from ..types.v_1_field_records import V1FieldRecords
from ..types.v_1_get_file_scan_status_response import V1GetFileScanStatusResponse
from ..types.v_1_insert_record_response import V1InsertRecordResponse
from ..types.v_1_update_record_response import V1UpdateRecordResponse
from .types.record_service_bulk_get_record_request_order_by import RecordServiceBulkGetRecordRequestOrderBy
from .types.record_service_bulk_get_record_request_redaction import RecordServiceBulkGetRecordRequestRedaction
from .types.record_service_get_record_request_redaction import RecordServiceGetRecordRequestRedaction

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawRecordsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def record_service_batch_operation(
        self,
        vault_id: str,
        *,
        records: typing.Optional[typing.Sequence[V1BatchRecord]] = OMIT,
        continue_on_error: typing.Optional[bool] = OMIT,
        byot: typing.Optional[V1Byot] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1BatchOperationResponse]:
        """
        Performs multiple record operations in a single transaction.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        records : typing.Optional[typing.Sequence[V1BatchRecord]]
            Record operations to perform.

        continue_on_error : typing.Optional[bool]
            Continue performing operations on partial errors.

        byot : typing.Optional[V1Byot]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1BatchOperationResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}",
            method="POST",
            json={
                "records": convert_and_respect_annotation_metadata(
                    object_=records, annotation=typing.Sequence[V1BatchRecord], direction="write"
                ),
                "continueOnError": continue_on_error,
                "byot": byot,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1BatchOperationResponse,
                    parse_obj_as(
                        type_=V1BatchOperationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def record_service_bulk_get_record(
        self,
        vault_id: str,
        object_name: str,
        *,
        skyflow_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        redaction: typing.Optional[RecordServiceBulkGetRecordRequestRedaction] = None,
        tokenization: typing.Optional[bool] = None,
        fields: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        offset: typing.Optional[str] = None,
        limit: typing.Optional[str] = None,
        download_url: typing.Optional[bool] = None,
        column_name: typing.Optional[str] = None,
        column_values: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        order_by: typing.Optional[RecordServiceBulkGetRecordRequestOrderBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1BulkGetRecordResponse]:
        """
        Gets the specified records from a table.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table that contains the records.

        skyflow_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            `skyflow_id` values of the records to return, with one value per `skyflow_ids` URL parameter. For example, `?skyflow_ids=abc&skyflow_ids=123`.<br /><br />If not specified, returns the first 25 records in the table.

        redaction : typing.Optional[RecordServiceBulkGetRecordRequestRedaction]
            Redaction level to enforce for the returned records. Subject to policies assigned to the API caller.

        tokenization : typing.Optional[bool]
            If `true`, this operation returns tokens for fields with tokenization enabled. Only applicable if `skyflow_id` values are specified.

        fields : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Fields to return for the record, with one value per `fields` URL parameter. For example, `?fields=abc&fields=123`.<br /><br />If not specified, returns all fields.

        offset : typing.Optional[str]
            Record position at which to start receiving data.

        limit : typing.Optional[str]
            Number of record to return. Maximum 25.

        download_url : typing.Optional[bool]
            If `true`, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.

        column_name : typing.Optional[str]
            Name of the column. It must be configured as unique in the schema. If you provide both column name or column value, you cannot use `skyflow_ids`. Passing either of these parameters with `skyflow_ids` returns an error.

        column_values : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Column values of the records to return, with one value per `column_values` URL parameter. For example, `?column_values=abc&column_values=123`.<br /><br />`column_name` is mandatory when providing `column_values`. If you use column name or column value, you cannot use `skyflow_ids`. Passing either of these parameters with `skyflow_ids` returns an error.

        order_by : typing.Optional[RecordServiceBulkGetRecordRequestOrderBy]
            Order to return records, based on `skyflow_id` values. To disable, set to `NONE`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1BulkGetRecordResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}",
            method="GET",
            params={
                "skyflow_ids": skyflow_ids,
                "redaction": redaction,
                "tokenization": tokenization,
                "fields": fields,
                "offset": offset,
                "limit": limit,
                "downloadURL": download_url,
                "column_name": column_name,
                "column_values": column_values,
                "order_by": order_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1BulkGetRecordResponse,
                    parse_obj_as(
                        type_=V1BulkGetRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def record_service_insert_record(
        self,
        vault_id: str,
        object_name: str,
        *,
        records: typing.Optional[typing.Sequence[V1FieldRecords]] = OMIT,
        tokenization: typing.Optional[bool] = OMIT,
        upsert: typing.Optional[str] = OMIT,
        homogeneous: typing.Optional[bool] = OMIT,
        byot: typing.Optional[V1Byot] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1InsertRecordResponse]:
        """
        Inserts a record in the specified table.<br /><br />The time-to-live (TTL) for a transient field begins when the field value is set during record insertion.<br /><br />Columns that have a string data type and a uniqueness constraint accept strings up to 2500 characters. If an inserted string exceeds 2500 characters, the call returns a token insertion error.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        records : typing.Optional[typing.Sequence[V1FieldRecords]]
            Record values and tokens.

        tokenization : typing.Optional[bool]
            If `true`, this operation returns tokens for fields with tokenization enabled.

        upsert : typing.Optional[str]
            Name of a unique column in the table. Uses upsert operations to check if a record exists based on the unique column's value. If a matching record exists, the record updates with the values you provide. If a matching record doesn't exist, the upsert operation inserts a new record.<br /><br />When you upsert a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn't included, it's removed.

        homogeneous : typing.Optional[bool]
            If `true`, this operation mandates that all the records have the same fields. This parameter does not work with upsert.

        byot : typing.Optional[V1Byot]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1InsertRecordResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}",
            method="POST",
            json={
                "records": convert_and_respect_annotation_metadata(
                    object_=records, annotation=typing.Sequence[V1FieldRecords], direction="write"
                ),
                "tokenization": tokenization,
                "upsert": upsert,
                "homogeneous": homogeneous,
                "byot": byot,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1InsertRecordResponse,
                    parse_obj_as(
                        type_=V1InsertRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def record_service_bulk_delete_record(
        self,
        vault_id: str,
        object_name: str,
        *,
        skyflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1BulkDeleteRecordResponse]:
        """
        Deletes the specified records from a table.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        skyflow_ids : typing.Optional[typing.Sequence[str]]
            `skyflow_id` values of the records to delete. If `*` is specified, this operation deletes all records in the table.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1BulkDeleteRecordResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}",
            method="DELETE",
            json={
                "skyflow_ids": skyflow_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1BulkDeleteRecordResponse,
                    parse_obj_as(
                        type_=V1BulkDeleteRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def record_service_get_record(
        self,
        vault_id: str,
        object_name: str,
        id: str,
        *,
        redaction: typing.Optional[RecordServiceGetRecordRequestRedaction] = None,
        tokenization: typing.Optional[bool] = None,
        fields: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        download_url: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1FieldRecords]:
        """
        Returns the specified record from a table.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        redaction : typing.Optional[RecordServiceGetRecordRequestRedaction]
            Redaction level to enforce for the returned record. Subject to policies assigned to the API caller.

        tokenization : typing.Optional[bool]
            If `true`, this operation returns tokens for fields with tokenization enabled. Only applicable if `skyflow_id` values are specified.

        fields : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Fields to return for the record, with one value per `fields` URL parameter. For example, `?fields=abc&fields=123`.<br /><br />If not specified, returns all fields.

        download_url : typing.Optional[bool]
            If `true`, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1FieldRecords]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}/{jsonable_encoder(id)}",
            method="GET",
            params={
                "redaction": redaction,
                "tokenization": tokenization,
                "fields": fields,
                "downloadURL": download_url,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1FieldRecords,
                    parse_obj_as(
                        type_=V1FieldRecords,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def record_service_update_record(
        self,
        vault_id: str,
        object_name: str,
        id: str,
        *,
        record: typing.Optional[V1FieldRecords] = OMIT,
        tokenization: typing.Optional[bool] = OMIT,
        byot: typing.Optional[V1Byot] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1UpdateRecordResponse]:
        """
        Updates the specified record in a table.<br /><br />When you update a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn't included, it's removed.<br /><br />The time-to-live (TTL) for a transient field resets when the field value is updated.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        record : typing.Optional[V1FieldRecords]

        tokenization : typing.Optional[bool]
            If `true`, this operation returns tokens for fields with tokenization enabled.

        byot : typing.Optional[V1Byot]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1UpdateRecordResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "record": convert_and_respect_annotation_metadata(
                    object_=record, annotation=V1FieldRecords, direction="write"
                ),
                "tokenization": tokenization,
                "byot": byot,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1UpdateRecordResponse,
                    parse_obj_as(
                        type_=V1UpdateRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def record_service_delete_record(
        self, vault_id: str, object_name: str, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[V1DeleteRecordResponse]:
        """
        Deletes the specified record from a table.<br /><br /><b>Note:</b> This method doesn't delete transient field tokens. Transient field values are available until they expire based on the fields' time-to-live (TTL) setting.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1DeleteRecordResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DeleteRecordResponse,
                    parse_obj_as(
                        type_=V1DeleteRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def file_service_upload_file(
        self,
        vault_id: str,
        object_name: str,
        id: str,
        *,
        file: typing.Optional[core.File] = OMIT,
        column_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1UpdateRecordResponse]:
        """
        Uploads a file to the specified record.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        file : typing.Optional[core.File]
            See core.File for more documentation

        column_name : typing.Optional[str]
            Name of the column to store the file in. The column must have a file data type.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1UpdateRecordResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}/{jsonable_encoder(id)}/files",
            method="POST",
            data={
                "columnName": column_name,
            },
            files={
                **({"file": file} if file is not None else {}),
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1UpdateRecordResponse,
                    parse_obj_as(
                        type_=V1UpdateRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def file_service_delete_file(
        self,
        vault_id: str,
        table_name: str,
        id: str,
        column_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1DeleteFileResponse]:
        """
        Deletes a file from the specified record.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        table_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        column_name : str
            Name of the column that contains the file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1DeleteFileResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(table_name)}/{jsonable_encoder(id)}/files/{jsonable_encoder(column_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DeleteFileResponse,
                    parse_obj_as(
                        type_=V1DeleteFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def file_service_get_file_scan_status(
        self,
        vault_id: str,
        table_name: str,
        id: str,
        column_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[V1GetFileScanStatusResponse]:
        """
        Returns the anti-virus scan status of a file.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        table_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        column_name : str
            Name of the column that contains the file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[V1GetFileScanStatusResponse]
            A successful response.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(table_name)}/{jsonable_encoder(id)}/files/{jsonable_encoder(column_name)}/scan-status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1GetFileScanStatusResponse,
                    parse_obj_as(
                        type_=V1GetFileScanStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_file_v_2(
        self,
        vault_id: str,
        *,
        table_name: str,
        column_name: str,
        file: core.File,
        skyflow_id: typing.Optional[str] = OMIT,
        return_file_metadata: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UploadFileV2Response]:
        """
        Uploads the specified file to a record. If an existing record isn't specified, creates a new record and uploads the file to that record.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        table_name : str
            Name of the table to upload the file to.

        column_name : str
            Name of the column to upload the file to. The column must have a `file` data type.

        file : core.File
            See core.File for more documentation

        skyflow_id : typing.Optional[str]
            Skyflow ID of the record to upload the file to. If `skyflowID` isn't specified, a new record will be created.

        return_file_metadata : typing.Optional[bool]
            If `true`, returns metadata about the uploaded file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UploadFileV2Response]
            File uploaded successfully.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/vaults/{jsonable_encoder(vault_id)}/files/upload",
            method="POST",
            data={
                "tableName": table_name,
                "columnName": column_name,
                "skyflowID": skyflow_id,
                "returnFileMetadata": return_file_metadata,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadFileV2Response,
                    parse_obj_as(
                        type_=UploadFileV2Response,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawRecordsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def record_service_batch_operation(
        self,
        vault_id: str,
        *,
        records: typing.Optional[typing.Sequence[V1BatchRecord]] = OMIT,
        continue_on_error: typing.Optional[bool] = OMIT,
        byot: typing.Optional[V1Byot] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1BatchOperationResponse]:
        """
        Performs multiple record operations in a single transaction.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        records : typing.Optional[typing.Sequence[V1BatchRecord]]
            Record operations to perform.

        continue_on_error : typing.Optional[bool]
            Continue performing operations on partial errors.

        byot : typing.Optional[V1Byot]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1BatchOperationResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}",
            method="POST",
            json={
                "records": convert_and_respect_annotation_metadata(
                    object_=records, annotation=typing.Sequence[V1BatchRecord], direction="write"
                ),
                "continueOnError": continue_on_error,
                "byot": byot,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1BatchOperationResponse,
                    parse_obj_as(
                        type_=V1BatchOperationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def record_service_bulk_get_record(
        self,
        vault_id: str,
        object_name: str,
        *,
        skyflow_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        redaction: typing.Optional[RecordServiceBulkGetRecordRequestRedaction] = None,
        tokenization: typing.Optional[bool] = None,
        fields: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        offset: typing.Optional[str] = None,
        limit: typing.Optional[str] = None,
        download_url: typing.Optional[bool] = None,
        column_name: typing.Optional[str] = None,
        column_values: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        order_by: typing.Optional[RecordServiceBulkGetRecordRequestOrderBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1BulkGetRecordResponse]:
        """
        Gets the specified records from a table.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table that contains the records.

        skyflow_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            `skyflow_id` values of the records to return, with one value per `skyflow_ids` URL parameter. For example, `?skyflow_ids=abc&skyflow_ids=123`.<br /><br />If not specified, returns the first 25 records in the table.

        redaction : typing.Optional[RecordServiceBulkGetRecordRequestRedaction]
            Redaction level to enforce for the returned records. Subject to policies assigned to the API caller.

        tokenization : typing.Optional[bool]
            If `true`, this operation returns tokens for fields with tokenization enabled. Only applicable if `skyflow_id` values are specified.

        fields : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Fields to return for the record, with one value per `fields` URL parameter. For example, `?fields=abc&fields=123`.<br /><br />If not specified, returns all fields.

        offset : typing.Optional[str]
            Record position at which to start receiving data.

        limit : typing.Optional[str]
            Number of record to return. Maximum 25.

        download_url : typing.Optional[bool]
            If `true`, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.

        column_name : typing.Optional[str]
            Name of the column. It must be configured as unique in the schema. If you provide both column name or column value, you cannot use `skyflow_ids`. Passing either of these parameters with `skyflow_ids` returns an error.

        column_values : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Column values of the records to return, with one value per `column_values` URL parameter. For example, `?column_values=abc&column_values=123`.<br /><br />`column_name` is mandatory when providing `column_values`. If you use column name or column value, you cannot use `skyflow_ids`. Passing either of these parameters with `skyflow_ids` returns an error.

        order_by : typing.Optional[RecordServiceBulkGetRecordRequestOrderBy]
            Order to return records, based on `skyflow_id` values. To disable, set to `NONE`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1BulkGetRecordResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}",
            method="GET",
            params={
                "skyflow_ids": skyflow_ids,
                "redaction": redaction,
                "tokenization": tokenization,
                "fields": fields,
                "offset": offset,
                "limit": limit,
                "downloadURL": download_url,
                "column_name": column_name,
                "column_values": column_values,
                "order_by": order_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1BulkGetRecordResponse,
                    parse_obj_as(
                        type_=V1BulkGetRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def record_service_insert_record(
        self,
        vault_id: str,
        object_name: str,
        *,
        records: typing.Optional[typing.Sequence[V1FieldRecords]] = OMIT,
        tokenization: typing.Optional[bool] = OMIT,
        upsert: typing.Optional[str] = OMIT,
        homogeneous: typing.Optional[bool] = OMIT,
        byot: typing.Optional[V1Byot] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1InsertRecordResponse]:
        """
        Inserts a record in the specified table.<br /><br />The time-to-live (TTL) for a transient field begins when the field value is set during record insertion.<br /><br />Columns that have a string data type and a uniqueness constraint accept strings up to 2500 characters. If an inserted string exceeds 2500 characters, the call returns a token insertion error.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        records : typing.Optional[typing.Sequence[V1FieldRecords]]
            Record values and tokens.

        tokenization : typing.Optional[bool]
            If `true`, this operation returns tokens for fields with tokenization enabled.

        upsert : typing.Optional[str]
            Name of a unique column in the table. Uses upsert operations to check if a record exists based on the unique column's value. If a matching record exists, the record updates with the values you provide. If a matching record doesn't exist, the upsert operation inserts a new record.<br /><br />When you upsert a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn't included, it's removed.

        homogeneous : typing.Optional[bool]
            If `true`, this operation mandates that all the records have the same fields. This parameter does not work with upsert.

        byot : typing.Optional[V1Byot]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1InsertRecordResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}",
            method="POST",
            json={
                "records": convert_and_respect_annotation_metadata(
                    object_=records, annotation=typing.Sequence[V1FieldRecords], direction="write"
                ),
                "tokenization": tokenization,
                "upsert": upsert,
                "homogeneous": homogeneous,
                "byot": byot,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1InsertRecordResponse,
                    parse_obj_as(
                        type_=V1InsertRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def record_service_bulk_delete_record(
        self,
        vault_id: str,
        object_name: str,
        *,
        skyflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1BulkDeleteRecordResponse]:
        """
        Deletes the specified records from a table.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        skyflow_ids : typing.Optional[typing.Sequence[str]]
            `skyflow_id` values of the records to delete. If `*` is specified, this operation deletes all records in the table.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1BulkDeleteRecordResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}",
            method="DELETE",
            json={
                "skyflow_ids": skyflow_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1BulkDeleteRecordResponse,
                    parse_obj_as(
                        type_=V1BulkDeleteRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def record_service_get_record(
        self,
        vault_id: str,
        object_name: str,
        id: str,
        *,
        redaction: typing.Optional[RecordServiceGetRecordRequestRedaction] = None,
        tokenization: typing.Optional[bool] = None,
        fields: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        download_url: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1FieldRecords]:
        """
        Returns the specified record from a table.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        redaction : typing.Optional[RecordServiceGetRecordRequestRedaction]
            Redaction level to enforce for the returned record. Subject to policies assigned to the API caller.

        tokenization : typing.Optional[bool]
            If `true`, this operation returns tokens for fields with tokenization enabled. Only applicable if `skyflow_id` values are specified.

        fields : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Fields to return for the record, with one value per `fields` URL parameter. For example, `?fields=abc&fields=123`.<br /><br />If not specified, returns all fields.

        download_url : typing.Optional[bool]
            If `true`, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1FieldRecords]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}/{jsonable_encoder(id)}",
            method="GET",
            params={
                "redaction": redaction,
                "tokenization": tokenization,
                "fields": fields,
                "downloadURL": download_url,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1FieldRecords,
                    parse_obj_as(
                        type_=V1FieldRecords,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def record_service_update_record(
        self,
        vault_id: str,
        object_name: str,
        id: str,
        *,
        record: typing.Optional[V1FieldRecords] = OMIT,
        tokenization: typing.Optional[bool] = OMIT,
        byot: typing.Optional[V1Byot] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1UpdateRecordResponse]:
        """
        Updates the specified record in a table.<br /><br />When you update a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn't included, it's removed.<br /><br />The time-to-live (TTL) for a transient field resets when the field value is updated.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        record : typing.Optional[V1FieldRecords]

        tokenization : typing.Optional[bool]
            If `true`, this operation returns tokens for fields with tokenization enabled.

        byot : typing.Optional[V1Byot]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1UpdateRecordResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "record": convert_and_respect_annotation_metadata(
                    object_=record, annotation=V1FieldRecords, direction="write"
                ),
                "tokenization": tokenization,
                "byot": byot,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1UpdateRecordResponse,
                    parse_obj_as(
                        type_=V1UpdateRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def record_service_delete_record(
        self, vault_id: str, object_name: str, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[V1DeleteRecordResponse]:
        """
        Deletes the specified record from a table.<br /><br /><b>Note:</b> This method doesn't delete transient field tokens. Transient field values are available until they expire based on the fields' time-to-live (TTL) setting.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1DeleteRecordResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DeleteRecordResponse,
                    parse_obj_as(
                        type_=V1DeleteRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def file_service_upload_file(
        self,
        vault_id: str,
        object_name: str,
        id: str,
        *,
        file: typing.Optional[core.File] = OMIT,
        column_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1UpdateRecordResponse]:
        """
        Uploads a file to the specified record.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        object_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        file : typing.Optional[core.File]
            See core.File for more documentation

        column_name : typing.Optional[str]
            Name of the column to store the file in. The column must have a file data type.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1UpdateRecordResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(object_name)}/{jsonable_encoder(id)}/files",
            method="POST",
            data={
                "columnName": column_name,
            },
            files={
                **({"file": file} if file is not None else {}),
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1UpdateRecordResponse,
                    parse_obj_as(
                        type_=V1UpdateRecordResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def file_service_delete_file(
        self,
        vault_id: str,
        table_name: str,
        id: str,
        column_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1DeleteFileResponse]:
        """
        Deletes a file from the specified record.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        table_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        column_name : str
            Name of the column that contains the file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1DeleteFileResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(table_name)}/{jsonable_encoder(id)}/files/{jsonable_encoder(column_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1DeleteFileResponse,
                    parse_obj_as(
                        type_=V1DeleteFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def file_service_get_file_scan_status(
        self,
        vault_id: str,
        table_name: str,
        id: str,
        column_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[V1GetFileScanStatusResponse]:
        """
        Returns the anti-virus scan status of a file.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        table_name : str
            Name of the table.

        id : str
            `skyflow_id` of the record.

        column_name : str
            Name of the column that contains the file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[V1GetFileScanStatusResponse]
            A successful response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/vaults/{jsonable_encoder(vault_id)}/{jsonable_encoder(table_name)}/{jsonable_encoder(id)}/files/{jsonable_encoder(column_name)}/scan-status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    V1GetFileScanStatusResponse,
                    parse_obj_as(
                        type_=V1GetFileScanStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_file_v_2(
        self,
        vault_id: str,
        *,
        table_name: str,
        column_name: str,
        file: core.File,
        skyflow_id: typing.Optional[str] = OMIT,
        return_file_metadata: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UploadFileV2Response]:
        """
        Uploads the specified file to a record. If an existing record isn't specified, creates a new record and uploads the file to that record.

        Parameters
        ----------
        vault_id : str
            ID of the vault.

        table_name : str
            Name of the table to upload the file to.

        column_name : str
            Name of the column to upload the file to. The column must have a `file` data type.

        file : core.File
            See core.File for more documentation

        skyflow_id : typing.Optional[str]
            Skyflow ID of the record to upload the file to. If `skyflowID` isn't specified, a new record will be created.

        return_file_metadata : typing.Optional[bool]
            If `true`, returns metadata about the uploaded file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UploadFileV2Response]
            File uploaded successfully.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/vaults/{jsonable_encoder(vault_id)}/files/upload",
            method="POST",
            data={
                "tableName": table_name,
                "columnName": column_name,
                "skyflowID": skyflow_id,
                "returnFileMetadata": return_file_metadata,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadFileV2Response,
                    parse_obj_as(
                        type_=UploadFileV2Response,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
